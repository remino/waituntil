#!/bin/sh
# waituntil

VERSION='0.3.0'

waituntil_main() {
	trap _exit INT TERM

	scriptinv="$( basename "$0" )"
	scriptpath="$( realpath "$0" )"
	scriptname="$( basename "$scriptpath" )"

	e_args=16
	e_invalid_format=17

	cmd=
	mode="$scriptinv"

	while getopts hv opt
	do
		case $opt in
			h) cmd=help ;;
			v) cmd=version ;;
			*) _invalid_opt ;;
		esac
	done

	[ $# -gt 0 ] && shift $(( OPTIND - 1 ))

	[ -z "$cmd" ] && cmd="process"

	case "$cmd" in
		help|process|version) "waituntil_$cmd" "$@" ;;
		*) _invalid_cmd ;;
	esac

	return $?
}

waituntil_process() {
	[ $# -lt 1 ] && waituntil_help && return

	iso_format="%Y-%m-%d %H:%M:%S"

	_init_date

	run_date="$1"
	shift

	_mode_is_runat && [ $# -lt 1 ] && _fatal $e_args 'Missing command.'

	_require_valid_date_format "$run_date"

	start_time_ts_ms="$( _format_date_to_epoch_ms "$run_date" )"
	[ -z "$start_time_ts_ms" ] && _fatal $e_invalid_format "Invalid date format: $run_date"

	now="$( _format_now_to_epoch_ms )"
	[ -z "$now" ] && _fatal $e_invalid_format "Could not convert date to Epoch ms."

	diff="$( echo "$start_time_ts_ms - $now" | bc )"
	start_time="$( _format_epoch_ms_to_date "$start_time_ts_ms" )"

	if [ "$diff" -gt 0 ]
	then
		wait_time="$( echo "scale=3; $diff / 1000" | bc )"
		echo "Waiting until $start_time ($wait_time s)..."
		sleep "$wait_time"
	else
		echo "Already past $start_time"
	fi

	[ $# -lt 1 ] || "$@"
}

waituntil_help() {
	_mode_is_runat && waituntil_help_runat && return

cat <<HELP
$scriptname $VERSION

Usage: $scriptinv [-hv] [-r <secs>] <start_time> [<command> [<args>]]

Wait until a specified time.

Run <command> at that specified time if one is specified.
If not, simply exit with code 0.

The <start_time> must be in ISO 8601 '%Y-%m-%d %H:%M:%S' format.

Time zone can be set with TZ environment variable.

Will try to locate Homebrew gdate (GNU date) on macOS.
If not present, will adapt to use BSD date, which has
less precision due to lack of millisecond output.

Examples:

	# Wait until 2022-07-07 10:00:00 local time then run echo:
	waituntil '2022-07-07 10:00:00' && echo Hi

	# Wait until 2022-07-07 10:00:00 Tokyo time then run echo:
	TZ=Asia/Tokyo waituntil '2022-07-07 10:00:00' && echo Hi

	# or
	TZ=Asia/Tokyo waituntil '2022-07-07 10:00:00' echo Hi

Available options:

	-h        Show this help screen.
	-v        Show script name and version number.

HELP
}

waituntil_help_runat() {
cat <<HELP
$scriptname $VERSION

Usage: $scriptinv [-hv] [-r <secs>] <start_time> <command> [<args>]

Wait until a specified time then run <command>.

The <start_time> must be in ISO 8601 '%Y-%m-%d %H:%M:%S' format.

Time zone can be set with TZ environment variable.

Will try to locate Homebrew gdate (GNU date) on macOS.
If not present, will adapt to use BSD date, which has
less precision due to lack of millisecond output.

Examples:

	# Wait until 2022-07-07 10:00:00 local time then run echo:
	runat '2022-07-07 10:00:00' echo Hi

	# Wait until 2022-07-07 10:00:00 Tokyo time then run echo:
	TZ=Asia/Tokyo runat '2022-07-07 10:00:00' echo Hi

Available options:

	-h        Show this help screen.
	-v        Show script name and version number.

HELP
}

waituntil_version() {
	_echo "$scriptname $VERSION"
}

_bsd_date() {
	_date -j 2>/dev/null > /dev/null
}

_date() {
	"$date" "$@"
}

_echo() {
	echo "$@"
}

_error() {
	_echo "$@" >&2
}

_exit() {
	exit_code=$?
	exit $exit_code
}

_fatal() {
	exit_code=$1
	shift
	_error "$@"
	exit "$exit_code"
}

_format_date_to_epoch_ms() {
	input_date="$1"

	if _bsd_date
	then
		_date -j -f "$iso_format" "$input_date" +"%s000" 2>/dev/null
	else
		_date -d "$input_date" +"%s%3N" 2>/dev/null
	fi
}

_format_epoch_ms_to_date() {
	format="+$iso_format %Z"
	epoch_ms="$1"
	epoch_s="$( echo "$epoch_ms / 1000" | bc )"

	if _bsd_date
	then
		_date -j -f "%s" "$epoch_s" "$format"
	else
		_date -d "@$epoch_s" "$format"
	fi
}

_format_now_to_epoch_ms() {
	if _bsd_date
	then
		_date +"%s000"
	else
		_date +"%s%3N"
	fi
}

_gnu_date() {
	! _bsd_date
}

_init_date() {
	gdate="$( which gdate )"
	[ $? -eq 0 ] && date="$gdate"
	[ -z "$date" ] && date="$( which date )"
}

_invalid_cmd() {
	_error "Invalid command: $cmd"
	_echo
	waituntil_help
	exit $e_args
}

_invalid_opt() {
	_error "Invalid option: $opt"
	_echo
	waituntil_help
	exit $e_args
}

_mode_is_runat() {
	[ "$mode" = "runat" ]
}

_require_valid_date_format() {
	input_date="$1"
	echo "$input_date" | grep -E '[0-9]{4}(-[0-9]{2}){2} ([0-9]{2}:){2}[0-9]{2}' > /dev/null 2>&1 && return
	_fatal $e_invalid_format "Invalid date format: $input_date"
}

waituntil_main "$@"
